<#macro join sequence separator empty_vaue="" list_ending="">
  <#if sequence?has_content>
    <#list sequence as item>
      <#lt>${item}<#rt>
      <#if item != sequence?last>
        <#lt>${separator}<#rt>
      </#if>
    </#list>
    <#lt>${list_ending}<#rt>
  <#else>
    <#lt>${empty_vaue}<#rt>
  </#if>
</#macro>

<#function namepath name>
  <#list module.remoteClasses as remoteClass>
    <#if remoteClass.name == name>
      <#local module_namespace=module_name>
      <#if remoteClass.abstract>
        <#local module_namespace=module_namespace+"/abstracts">
      </#if>
      <#return "module:"+module_namespace+"."+name>
    </#if>
  </#list>

  <#if module.complexTypes??>
    <#list module.complexTypes as complexType>
      <#if complexType.name == name>
        <#local module_namespace=module_name+"/complexTypes">
        <#return "module:"+module_namespace+"."+name>
      </#if>
    </#list>
  </#if>

  <#if module.imports??>
    <#list module.imports as import>
      <#list import.module.remoteClasses as remoteClass>
        <#if remoteClass.name == name>
          <#local module_namespace=import.name>
          <#if remoteClass.abstract>
            <#local module_namespace=module_namespace+"/abstracts">
          </#if>
          <#return "module:"+module_namespace+"."+name>
        </#if>
      </#list>

      <#if import.complexTypes??>
        <#list import.complexTypes as complexType>
          <#if complexType.name == name>
            <#local module_namespace=module_name+"/complexTypes">
            <#return "module:"+module_namespace+"."+name>
          </#if>
        </#list>
      </#if>
    </#list>
  </#if>

  <#switch name>
    <#case "boolean">
      <#return "external:Boolean">
    <#case "float">
      <#return "external:Number">
    <#case "int">
      <#return "external:Integer">
  </#switch>

  <#return "external:"+name>
</#function>

<#macro arguments params>
  var transaction = (arguments[0] instanceof Transaction)
                  ? Array.prototype.shift.apply(arguments)
                  : undefined;

  <#if params?has_content>
    <#list params as param>
      <#if param.optional>
  callback = arguments[arguments.length-1] instanceof Function
           ? Array.prototype.pop.call(arguments)
           : undefined;

  switch(arguments.length){
        <#local params_min=0>
        <#local params_max=params?size>
        <#list params as param>
          <#if param.optional>
    case ${param_index}: ${param.name} = undefined;
          <#else>
            <#local params_min=params_min+1>
          </#if>
        </#list>
    break;

    default:
      var error = new RangeError('Number of params ('+arguments.length+') not in range ['+${params_min}+'-'+${params_max}+']');
          error.length = arguments.length;
          error.min = ${params_min};
          error.max = ${params_max};

      throw error;
  }

        <#break>
      </#if>
    </#list>
    <#list params as param>
  checkType('${param.type.name}', '${param.name}', ${param.name}<#if param.type.isList() || !param.optional>, {<#if param.type.isList()>isList: true,</#if><#if !param.optional>required: true</#if>}</#if>);
    </#list>

  var params = {
    <#list methodParams_name as name>
    ${name}: ${name},
    </#list>
  };
  <#else>
  if(!arguments.length) callback = undefined;
  </#if>

</#macro>
